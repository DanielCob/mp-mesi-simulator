# Plan de Ejecuci√≥n SOLO + IA - Simulador MESI Multiprocesador

**Proyecto:** Simulador de Sistema Multiprocesador con Coherencia MESI  
**Curso:** CE-4302 Arquitectura de Computadores II  
**Plazo:** 4 D√çAS (96 horas)  
**Fecha l√≠mite:** 21-22 de octubre de 2025  
**Modo:** 1 DESARROLLADOR + COPILOT/CLAUDE

---

## ü§ñ ESTRATEGIA: DESARROLLADOR + IA

**T√∫:** Arquitectura, decisiones, integraci√≥n, pruebas  
**IA (Copilot/Claude):** Generaci√≥n de c√≥digo, boilerplate, documentaci√≥n, debugging

---

## üìä Estado Actual del Proyecto

### ‚úÖ YA IMPLEMENTADO (60%)

| Componente | Estado |
|------------|--------|
| **Estructura de Cache** | ‚úÖ 2-way, 16 bloques, 32 bytes/bloque |
| **Protocolo MESI** | ‚úÖ Estados M, E, S, I |
| **Bus Handlers** | ‚úÖ BUS_RD, BUS_RDX, BUS_UPGR, BUS_WB |
| **Memoria Principal** | ‚úÖ 512 x 64 bits con mutex |
| **Threading Base** | ‚úÖ 4 threads de PEs |
| **Cache Read/Write** | ‚úÖ Con coherencia MESI |
| **Pol√≠tica de Reemplazo** | ‚úÖ Con writeback autom√°tico |

### ‚ùå FALTA IMPLEMENTAR (40%)

| Componente | Prioridad | Tiempo | Estrategia IA |
|------------|-----------|--------|---------------|
| **Banco de Registros** | üî¥ | 45 min | IA genera struct y funciones |
| **ISA B√°sica** | üî¥ | 1.5h | IA genera switch/case por instrucci√≥n |
| **ISA Completa** | üî¥ | 1h | IA completa el resto |
| **Cargador de C√≥digo** | üî¥ | 1.5h | IA genera parser de texto |
| **Mutex por Cache** | üî¥ | 30 min | IA a√±ade locks autom√°ticamente |
| **Producto Punto** | üî¥ | 2h | IA genera c√≥digo assembly |
| **Estad√≠sticas** | üü° | 1h | IA genera contadores y prints |
| **Validaci√≥n** | üî¥ | 45 min | IA genera tests |
| **README** | üü° | 1h | IA genera documentaci√≥n |
| **Video** | üü° | 1.5h | T√∫ grabas, IA ayuda con script |
| **Art√≠culo** | üü° | 2h | IA ayuda con estructura LaTeX |

**Total: ~13.5 horas de desarrollo (3-4h por d√≠a)**

---

## üóìÔ∏è CRONOGRAMA INTENSIVO SOLO + IA

### **D√çA 1 (Viernes): FUNDAMENTOS** - 3-4 horas
**Objetivo:** ISA completa y registros funcionando

#### üïê 08:00-09:00 (1h) - Banco de Registros
```bash
# Prompt para IA:
"Implementa un banco de 8 registros de 64 bits (double) en C.
Incluye:
- Estructura RegisterFile con array regs[8] y program counter (pc)
- Funciones: reg_init, reg_read(id), reg_write(id, value)
- Archivos: src/pe/registers.h y src/pe/registers.c"

# T√∫:
- Revisar c√≥digo generado
- Compilar y probar
- Ajustar si es necesario
```

#### üïê 09:30-11:00 (1.5h) - ISA B√°sica
```bash
# Prompt para IA:
"Implementa una ISA simple en C con estas instrucciones:
- LOAD Rd, [addr]   : Lee de memoria a registro
- STORE Rs, [addr]  : Escribe registro a memoria  
- FADD Rd, Ra, Rb   : Suma flotante Rd = Ra + Rb
- FMUL Rd, Ra, Rb   : Multiplicaci√≥n Rd = Ra * Rb

Estructura:
- enum OpCode { OP_LOAD, OP_STORE, OP_FADD, OP_FMUL }
- struct Instruction { OpCode op; int rd, ra, rb; int addr; }
- void execute_instruction(Instruction* inst, RegisterFile* rf, Cache* cache, int pe_id)

Archivos: src/pe/isa.h y src/pe/isa.c
Usa las funciones cache_read() y cache_write() existentes."

# T√∫:
- Integrar con cache existente
- Probar cada instrucci√≥n
- Verificar coherencia MESI
```

#### üïê 11:30-12:30 (1h) - Completar ISA
```bash
# Prompt para IA:
"A√±ade estas instrucciones al ISA:
- INC Rd        : Incrementa registro (Rd = Rd + 1)
- DEC Rd        : Decrementa registro (Rd = Rd - 1)
- JNZ Rd, label : Salta si Rd != 0
- HALT          : Termina ejecuci√≥n

Actualiza execute_instruction() con un switch/case completo."

# T√∫:
- Probar JNZ con loop simple
- Validar HALT
```

#### üïê 14:00-15:30 (1.5h) - Cargador de C√≥digo
```bash
# Prompt para IA:
"Implementa un cargador que parsee c√≥digo assembly desde texto:

Formato de entrada:
LOAD R0 100
LOAD R1 104
FMUL R2 R0 R1
STORE R2 200
HALT

Estructura:
- struct Program { Instruction* code; int size; }
- Program load_program(const char* filename)
- Parsear l√≠nea por l√≠nea con sscanf

Archivos: src/pe/loader.h y src/pe/loader.c"

# T√∫:
- Crear archivo de prueba test.asm
- Cargar y ejecutar
- Depurar parser
```

**CHECKPOINT D√çA 1 (16:00):**
```bash
# Probar programa completo:
echo "LOAD R0 0
LOAD R1 1  
FADD R2 R0 R1
STORE R2 10
HALT" > test.asm

./mesi_simulator test.asm
```
- ‚úÖ ISA ejecuta todas las instrucciones
- ‚úÖ Registros funcionan
- ‚úÖ Carga c√≥digo desde archivo

---

### **D√çA 2 (S√°bado): PRODUCTO PUNTO** - 4-5 horas
**Objetivo:** Aplicaci√≥n paralela funcionando

#### üïê 08:00-09:00 (1h) - Mutex por Cache
```bash
# Prompt para IA:
"A√±ade pthread_mutex_t a la estructura Cache y protege estas funciones:
- cache_read()
- cache_write()
- cache_get_state()
- cache_set_state()
- cache_get_data()
- cache_set_data()

Usa pthread_mutex_lock/unlock apropiadamente.
Evita deadlocks siguiendo este orden:
1. Lock cache local
2. Lock bus (si es necesario)
3. Lock otros caches (en orden de ID)

Modifica src/cache/cache.h y src/cache/cache.c"

# T√∫:
- Compilar y verificar no hay deadlocks
- Probar con helgrind
```

#### üïê 09:30-11:30 (2h) - Generar C√≥digo de Producto Punto
```bash
# Prompt para IA:
"Genera c√≥digo assembly para producto punto paralelo:

Entrada: 
- Vector A[N] en memoria empezando en addr 0
- Vector B[N] en memoria empezando en addr N*8
- N = 16 (divisible entre 4 PEs)

Cada PE procesa N/4 elementos:
- PE0: elementos 0-3
- PE1: elementos 4-7
- PE2: elementos 8-11
- PE3: elementos 12-15

C√≥digo para PE0 (ajustar √≠ndices para otros PEs):

# Inicializaci√≥n
LOAD R0 0      # start_A = 0
LOAD R1 128    # start_B = N*8 = 16*8
LOAD R2 4      # count = N/4 = 4
LOAD R3 0      # acum = 0

LOOP:
  LOAD R4 [R0]   # A[i]
  LOAD R5 [R1]   # B[i]
  FMUL R6 R4 R5  # A[i] * B[i]
  FADD R3 R3 R6  # acum += producto
  INC R0         # Avanzar 8 bytes en A (pero como addr, +8)
  INC R1         # Avanzar 8 bytes en B
  DEC R2         # count--
  JNZ R2 LOOP

STORE R3 256   # Guardar resultado en addr 256+pe_id*8
HALT

Genera 4 archivos: pe0.asm, pe1.asm, pe2.asm, pe3.asm
Ajusta direcciones para cada PE."

# T√∫:
- Revisar direcciones de memoria
- Ajustar para double = 8 bytes
- Cargar vectores A y B en memoria
```

#### üïê 12:00-13:00 (1h) - C√≥digo de Reducci√≥n
```bash
# Prompt para IA:
"Genera c√≥digo para PE0 que sume los 4 resultados parciales:

# Resultados parciales est√°n en addrs 256, 264, 272, 280
LOAD R0 256    # parcial PE0
LOAD R1 264    # parcial PE1
LOAD R2 272    # parcial PE2  
LOAD R3 280    # parcial PE3

FADD R4 R0 R1
FADD R4 R4 R2
FADD R4 R4 R3

STORE R4 300   # resultado final
HALT

Guarda en pe0_reduce.asm"

# T√∫:
- Implementar sincronizaci√≥n con barriers
- PE0 espera a que todos terminen
- PE0 ejecuta reducci√≥n
```

#### üïê 14:00-15:00 (1h) - Validaci√≥n
```bash
# Prompt para IA:
"Genera test de validaci√≥n:

1. Implementaci√≥n secuencial de producto punto en C
2. Generar vectores de prueba: A = {1,2,3,...,16}, B = {1,1,1,...,1}
3. Resultado esperado = 1+2+3+...+16 = 136
4. Cargar vectores en memoria del simulador
5. Ejecutar simulador paralelo
6. Comparar resultados (tolerancia 0.0001 para punto flotante)

Archivo: tests/test_dot_product.c"

# T√∫:
- Ejecutar test
- Depurar si falla
- Probar con N=4, N=16, N=64
```

#### üïê 15:30-16:30 (1h) - Barriers y Sincronizaci√≥n
```bash
# Prompt para IA:
"Implementa sincronizaci√≥n con pthread_barrier_t:

En src/main.c:
1. Inicializar pthread_barrier_t con NUM_PES threads
2. Despu√©s de cargar c√≥digo: barrier_wait (todos empiezan juntos)
3. Despu√©s de c√°lculo: barrier_wait (todos terminan antes de reducci√≥n)

Modifica pe_run() en src/pe/pe.c para:
- Ejecutar programa mientras inst != HALT
- Llamar barrier_wait despu√©s de terminar"

# T√∫:
- Verificar orden de ejecuci√≥n
- Asegurar que PE0 hace reducci√≥n al final
```

**CHECKPOINT D√çA 2 (17:00):**
```bash
make clean && make
./mesi_simulator --dot-product N=16

# Debe imprimir:
# Vector A: [1.0, 2.0, ..., 16.0]
# Vector B: [1.0, 1.0, ..., 1.0]
# Resultado esperado: 136.0
# Resultado simulador: 136.0
# ‚úÖ CORRECTO
```
- ‚úÖ Producto punto paralelo funciona
- ‚úÖ Resultado validado
- ‚úÖ Coherencia MESI mantenida

---

### **D√çA 3 (Domingo): ESTAD√çSTICAS Y DOCS** - 3-4 horas
**Objetivo:** Estad√≠sticas, README, art√≠culo (borrador)

#### üïê 08:00-09:00 (1h) - Sistema de Estad√≠sticas
```bash
# Prompt para IA:
"Implementa sistema de estad√≠sticas en src/cache/stats.h/c:

struct CacheStats {
    int read_hits;
    int read_misses;
    int write_hits;
    int write_misses;
    int invalidations_busrdx;
    int invalidations_busupgr;
    int writebacks;
    int bus_transactions;
    int mesi_transitions[4][4];  // [from_state][to_state]
};

Funciones:
- stats_init(stats)
- stats_record_hit(stats, is_write)
- stats_record_miss(stats, is_write)
- stats_record_invalidation(stats, bus_msg)
- stats_record_writeback(stats)
- stats_record_transition(stats, from, to)
- stats_print(stats, pe_id)

Integrar en:
- cache_read(): record_hit o record_miss
- cache_write(): record_hit o record_miss
- handlers: record_invalidation, record_writeback
- cache_set_state(): record_transition

Imprimir tabla bonita al final:
PE0 Statistics:
  Read Hits:    45
  Read Misses:  3
  Write Hits:   12
  Write Misses: 2
  ...
  
MESI Transitions:
     I   E   S   M
  I  0   8   2   0
  E  0   0   3   5
  S  4   0   0   3
  M  2   0   0   0
"

# T√∫:
- Ejecutar simulador
- Verificar que n√∫meros tienen sentido
- Ajustar formato de salida
```

#### üïê 09:30-10:30 (1h) - README Completo
```bash
# Prompt para IA:
"Genera README.md completo con:

# Simulador MESI Multiprocesador

## Descripci√≥n
Sistema multiprocesador de 4 PEs con coherencia de cach√© MESI...

## Arquitectura
- 4 Processing Elements (PEs)
- Cache 2-way set associative, 16 bloques, 32 bytes/bloque
- Protocolo MESI (Modified, Exclusive, Shared, Invalid)
- Memoria compartida 512 x 64 bits
- Bus compartido con arbitraje por mutex

## Compilaci√≥n
```bash
make clean
make
```

## Uso
```bash
# Ejecutar producto punto con N elementos
./mesi_simulator --dot-product N=16

# Ejecutar programa custom
./mesi_simulator program.asm

# Modo debug (verbose)
./mesi_simulator --debug program.asm
```

## Estructura de C√≥digo Assembly
...

## Ejemplos
...

## Estad√≠sticas
...

## Autores
[Tu nombre]

## Referencias
...
"

# T√∫:
- Revisar y completar secciones
- A√±adir screenshots si es posible
```

#### üïê 11:00-13:00 (2h) - Art√≠culo Cient√≠fico (Borrador)
```bash
# Prompt para IA:
"Genera estructura de art√≠culo IEEE en LaTeX:

\documentclass[conference]{IEEEtran}
\usepackage{graphicx}
\usepackage{cite}

\title{Simulador de Sistema Multiprocesador con Protocolo MESI}
\author{\IEEEauthorblockN{[Tu Nombre]}
\IEEEauthorblockA{Instituto Tecnol√≥gico de Costa Rica}}

\begin{document}

\maketitle

\begin{abstract}
Este trabajo presenta la implementaci√≥n de un simulador de sistema multiprocesador con 4 n√∫cleos que utiliza el protocolo de coherencia de cach√© MESI. El simulador fue desarrollado en C con soporte para threading mediante POSIX threads. Se implement√≥ una ISA simple y se valid√≥ con el c√°lculo paralelo del producto punto de dos vectores. Los resultados muestran... [COMPLETAR]
\end{abstract}

\section{Introduction}
El problema de la coherencia de cach√© es cr√≠tico en sistemas multiprocesador modernos...

\section{Related Work}
El protocolo MESI fue propuesto por Papamarcos y Patel en 1984...

\section{System Architecture}
\subsection{Cache Organization}
Cada PE tiene una cach√© privada de 2 v√≠as...

\subsection{MESI Protocol}
El protocolo mantiene 4 estados...

\section{Implementation}
\subsection{ISA Design}
Se implementaron 8 instrucciones...

\subsection{Threading Model}
Se utiliz√≥ un thread por PE m√°s mutex para sincronizaci√≥n...

\section{Experimental Results}
\subsection{Test Setup}
Se prob√≥ con vectores de tama√±o N=16...

\subsection{Cache Statistics}
[TABLA CON HITS/MISSES]

\subsection{MESI Transitions}
[TABLA CON TRANSICIONES]

\subsection{Performance Analysis}
[GR√ÅFICA DE SPEEDUP SI HAY TIEMPO]

\section{Conclusion}
Se implement√≥ exitosamente un simulador...

\begin{thebibliography}{1}
\bibitem{mesi}
Papamarcos, M.S. and Patel, J.H., 
\emph{A Low-Overhead Coherence Solution for Multiprocessors with Private Cache Memories}, 
ISCA 1984.
\end{thebibliography}

\end{document}
"

# T√∫:
- Completar secciones con datos reales
- A√±adir tablas de estad√≠sticas
- Generar PDF con pdflatex
```

**CHECKPOINT D√çA 3 (14:00):**
- ‚úÖ Estad√≠sticas funcionando
- ‚úÖ README completo
- ‚úÖ Art√≠culo borrador en LaTeX
- ‚úÖ Tablas con datos reales

---

### **D√çA 4 (Lunes): VIDEO Y ENTREGA** - 2-3 horas
**Objetivo:** Video, revisi√≥n final, entrega

#### üïê 08:00-08:30 (30 min) - Script del Video
```bash
# Prompt para IA:
"Genera script para video de 4:30-5:00 minutos:

[00:00-00:30] INTRODUCCI√ìN
- Hola, soy [nombre]
- Proyecto: Simulador MESI multiprocesador
- Objetivo: Coherencia de cach√© en 4 PEs

[00:30-01:30] ARQUITECTURA
- Mostrar diagrama de bloques
- Explicar: 4 PEs, caches privadas, bus compartido, memoria
- Protocolo MESI: 4 estados (M, E, S, I)

[01:30-03:00] DEMO EN VIVO
- Compilar c√≥digo: make
- Ejecutar producto punto: ./mesi_simulator --dot-product N=16
- Mostrar mensajes de debug (BUS_RD, invalidaciones, etc.)
- Mostrar resultado: 136.0 ‚úì

[03:00-04:00] RESULTADOS
- Mostrar tabla de estad√≠sticas
- Cache hit rate: ~93%
- Transiciones MESI m√°s comunes
- Writebacks: cuando se expulsa l√≠nea M

[04:00-04:30] CONCLUSIONES
- Protocolo MESI funciona correctamente
- Coherencia garantizada
- Aplicaci√≥n paralela validada
- Gracias por su atenci√≥n

---
TIPS PARA GRABAR:
- Usar OBS Studio
- Resoluci√≥n 1280x720
- Hablar claro y pausado
- Tener terminal con fuente grande
- Tener diagrama a mano
"

# T√∫:
- Ensayar script 2-3 veces
- Preparar ventanas de terminal
- Tener diagramas listos
```

#### üïê 09:00-10:30 (1.5h) - Grabar y Editar Video
```bash
# T√∫:
1. Abrir OBS Studio
2. Configurar captura de pantalla + audio
3. Grabar siguiendo script (2-3 tomas si es necesario)
4. Editar con:
   - Cortar errores
   - A√±adir t√≠tulos de secci√≥n
   - M√∫sica de fondo suave (opcional)
5. Exportar MP4 en HD
6. Verificar que dura 4:30-5:30
```

#### üïê 11:00-12:00 (1h) - Revisi√≥n Final de C√≥digo
```bash
# Checklist:
make clean
make 2>&1 | grep -i warning   # No debe haber warnings

valgrind --leak-check=full ./mesi_simulator test.asm
# No debe haber leaks

./tests/test_dot_product
# Todos los tests deben pasar

# Revisar que todos los archivos est√©n:
ls -R src/
# pe/registers.h, pe/registers.c
# pe/isa.h, pe/isa.c
# pe/loader.h, pe/loader.c
# cache/stats.h, cache/stats.c
# ... etc
```

#### üïê 12:30-13:00 (30 min) - Completar Art√≠culo
```bash
# T√∫:
- A√±adir estad√≠sticas reales a las tablas
- Completar secci√≥n de resultados
- Revisar ortograf√≠a
- Generar PDF final:

pdflatex articulo.tex
bibtex articulo
pdflatex articulo.tex
pdflatex articulo.tex

# Verificar que se ve bien
```

#### üïê 13:30-14:00 (30 min) - Slides de Defensa
```bash
# Prompt para IA:
"Genera 12 slides en formato Markdown/Google Slides:

1. T√≠tulo + Nombre
2. Objetivos del Proyecto
3. Arquitectura General (diagrama)
4. Protocolo MESI (FSM)
5. Implementaci√≥n - Cache
6. Implementaci√≥n - ISA
7. Aplicaci√≥n: Producto Punto
8. Demo en Vivo [AQU√ç EJECUTAS]
9. Resultados - Estad√≠sticas
10. Resultados - An√°lisis
11. Conclusiones
12. Preguntas

Cada slide con m√°ximo 5 bullets, letra grande."

# T√∫:
- Convertir a PowerPoint/PDF
- A√±adir gr√°ficas si hay tiempo
- Ensayar presentaci√≥n (15 min)
```

#### üïê 14:30-15:30 (1h) - Empaquetar y Subir
```bash
# Estructura del ZIP:
MESI-Simulator-[TuNombre]/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ pe/
‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îú‚îÄ‚îÄ bus/
‚îÇ   ‚îú‚îÄ‚îÄ memory/
‚îÇ   ‚îú‚îÄ‚îÄ sync/
‚îÇ   ‚îî‚îÄ‚îÄ main.c
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ programs/
‚îÇ   ‚îú‚îÄ‚îÄ pe0.asm
‚îÇ   ‚îú‚îÄ‚îÄ pe1.asm
‚îÇ   ‚îú‚îÄ‚îÄ pe2.asm
‚îÇ   ‚îî‚îÄ‚îÄ pe3.asm
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ articulo.pdf
‚îÇ   ‚îî‚îÄ‚îÄ diagramas/
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ video_presentacion.mp4  # O link a YouTube

# Crear ZIP:
zip -r MESI-Simulator.zip MESI-Simulator/ -x "*.o" "*.out" "*mesi_simulator"

# Verificar tama√±o < 50 MB
ls -lh MESI-Simulator.zip

# Subir a Tec Digital ANTES de 23:59
```

**CHECKPOINT D√çA 4 (16:00):**
- ‚úÖ Video subido (YouTube/Drive)
- ‚úÖ Art√≠culo PDF completo
- ‚úÖ Slides de defensa listos
- ‚úÖ ZIP creado y verificado
- ‚úÖ SUBIDO A TEC DIGITAL ‚úÖ
- ‚úÖ Confirmaci√≥n de entrega recibida

---

## ü§ñ PROMPTS CLAVE PARA IA

### Para Generar C√≥digo
```
"Implementa [componente] en C siguiendo este spec:
- Estructuras: [listar]
- Funciones: [listar]
- Archivos: src/[path]
- Debe integrarse con: [componentes existentes]
- Usar estos tipos: [tipos del proyecto]"
```

### Para Debugging
```
"Tengo este error de compilaci√≥n:
[pegar error]

En este c√≥digo:
[pegar c√≥digo]

¬øCu√°l es el problema y c√≥mo lo soluciono?"
```

### Para Documentaci√≥n
```
"Genera documentaci√≥n en formato [Markdown/LaTeX] para:
- Componente: [nombre]
- Funcionalidad: [descripci√≥n]
- Uso: [ejemplos]
- Formato: [estilo espec√≠fico]"
```

### Para Tests
```
"Genera test unitario para [funci√≥n/m√≥dulo]:
- Input: [casos de prueba]
- Expected output: [resultados esperados]
- Edge cases: [casos l√≠mite]
- Framework: simple asserts en C"
```

---

## ‚ö° OPTIMIZACIONES PARA 1 PERSONA + IA

### LO QUE IA HACE EXCELENTE
‚úÖ Generar boilerplate (structs, headers)  
‚úÖ Implementar funciones simples  
‚úÖ Parsear texto (loader)  
‚úÖ Generar documentaci√≥n  
‚úÖ Crear tests b√°sicos  
‚úÖ Formatear LaTeX/Markdown  

### LO QUE T√ö DEBES HACER
üéØ Arquitectura y decisiones de dise√±o  
üéØ Integraci√≥n entre componentes  
üéØ Debugging de race conditions  
üéØ Validaci√≥n de coherencia MESI  
üéØ Grabar y editar video  
üéØ Ensayar presentaci√≥n  

### LO QUE SIMPLIFICAMOS
üî∂ Threading del bus: solo mutex, no cola compleja  
üî∂ Visualizaci√≥n: solo printf, no GUI  
üî∂ Tests: solo el producto punto  
üî∂ Diagramas: solo los esenciales (draw.io simple)  

---

## üö® GESTI√ìN DE RIESGOS (1 PERSONA)

| Riesgo | Probabilidad | Mitigaci√≥n |
|--------|--------------|------------|
| **IA genera c√≥digo con bugs** | Alta | Revisar antes de integrar, compilar frecuentemente |
| **Race condition dif√≠cil** | Media | Usar helgrind, simplificar threading |
| **No hay tiempo para video** | Media | Grabar mientras desarrollas (screen recording) |
| **Art√≠culo incompleto** | Baja | README extenso puede compensar |
| **Producto punto falla** | Media | Validar con N peque√±o primero (N=4) |

---

## üìä M√âTRICAS DE √âXITO M√çNIMAS

### D√çA 1 (30% avance) - 4h
- ‚úÖ ISA ejecuta todas las instrucciones
- ‚úÖ Carga c√≥digo desde archivo

### D√çA 2 (70% avance) - 4h
- ‚úÖ Producto punto da resultado correcto
- ‚úÖ Coherencia MESI funciona

### D√çA 3 (90% avance) - 3h
- ‚úÖ Estad√≠sticas impresas
- ‚úÖ README completo
- ‚úÖ Art√≠culo borrador

### D√çA 4 (100% avance) - 3h
- ‚úÖ Video grabado
- ‚úÖ Entregado en Tec Digital

---

## üõ†Ô∏è HERRAMIENTAS ESENCIALES

### Desarrollo
- **VSCode** con GitHub Copilot
- **GCC** para compilar
- **GDB** para debugging
- **Valgrind** para memory leaks
- **Helgrind** para race conditions

### Documentaci√≥n
- **Overleaf** para art√≠culo LaTeX
- **draw.io** para diagramas
- **Typora** para editar Markdown

### Video
- **OBS Studio** para grabar pantalla
- **DaVinci Resolve** (free) para editar
- **YouTube** para subir video

### Comunicaci√≥n con IA
- **Claude** (este chat) para arquitectura
- **GitHub Copilot** para c√≥digo en tiempo real
- **ChatGPT** como backup

---

## ‚úÖ CHECKLIST DE ENTREGA FINAL

### C√≥digo (CR√çTICO)
- [ ] Compila sin errores ni warnings
- [ ] Ejecuta producto punto correctamente
- [ ] Coherencia MESI validada
- [ ] Estad√≠sticas se imprimen

### Archivos Requeridos
- [ ] src/ completo
- [ ] Makefile funcional
- [ ] README.md
- [ ] programs/*.asm (c√≥digo de PEs)
- [ ] articulo.pdf
- [ ] video_presentacion.mp4 (o link)

### Entrega
- [ ] ZIP < 50 MB
- [ ] Nombre correcto: MESI-Simulator-[Nombre]
- [ ] Subido antes de 23:59
- [ ] Confirmaci√≥n recibida

### Defensa (preparaci√≥n)
- [ ] Slides listos (10-12 slides)
- [ ] Demo funcional preparada
- [ ] Respuestas a preguntas t√≠picas preparadas

---

## üí™ MOTIVACI√ìN SOLO + IA

```
D√çA 1: "Foundation with AI assist" ü§ñ
D√çA 2: "Make it work together" üîß
D√çA 3: "Document everything" üìù
D√çA 4: "Ship it!" üöÄ
```

**¬°T√ö PUEDES HACERLO! üí™**

Con IA como copiloto, esto es totalmente factible. La clave es:
- **Iterar r√°pido**: Compilar y probar frecuentemente
- **Pedir ayuda a IA**: No escribas boilerplate manualmente
- **Enfocarte en integraci√≥n**: IA genera piezas, t√∫ las unes
- **Validar siempre**: No conf√≠es ciegamente en c√≥digo generado

---

## üéØ SIGUIENTE PASO INMEDIATO

**EMPIEZA AHORA:**

```bash
cd src/pe
touch registers.h registers.c

# Prompt para Claude/Copilot:
"Implementa banco de 8 registros de 64 bits (double) en C..."
```

**¬°ARRANCA EL D√çA 1! üöÄ**

---

**√öltima actualizaci√≥n:** [Hoy]  
**Modo:** SOLO + IA (Claude/Copilot)  
**Desarrollador:** [Tu nombre]  
**Lema:** "Code smart, not hard" üß†

---